#include "userprog/syscall.h"
#include <stdio.h>
#include <syscall-nr.h>
#include "threads/interrupt.h"
#include "threads/thread.h"
#include "threads/vaddr.h"
#include "userprog/process.h"
#include "filesys/filesys.h"
#include "filesys/file.h"
#include "filesys/off_t.h"
#include "devices/block.h"

void syscall_handler(struct intr_frame *);

struct file
{
  struct inode* inode;
  off_t pos;
  bool deny_write;
};

struct file* getfile(int fd);
void check_user_vaddr(const void* vaddr);

void
syscall_init (void) 
{
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
}

void sys_halt(void);
void sys_exit(int status);
int sys_exec(const char *file);
int sys_wait(int pid);
bool sys_create(const char *file, unsigned initial_size);
bool sys_remove(const char *file);
int sys_write(int fd, const void *buffer, unsigned size);
int sys_open(const char* file);
int sys_filesize(int fd);
void sys_seek(int fd, unsigned position);
unsigned sys_tell(int fd);
void sys_close(int fd);
int sys_read(int fd,const void *buffer, unsigned size);


void syscall_handler(struct intr_frame *f){
  uint32_t syscall_number = *((uint32_t *)f->esp);
  switch(syscall_number){
    case SYS_HALT:
      sys_halt();
      break;
    case SYS_EXIT:  
      check_user_vaddr(*(int*)(f->esp+4));
      sys_exit(*(int*)(f->esp+4));
      break;
    case SYS_EXEC:
      f->eax = sys_exec((const char*)*(int *)(f->esp+4));
      break;
    case SYS_WAIT:
      f->eax = sys_wait(*(int *)(f->esp+4));
      break;
    case SYS_CREATE:
      f->eax = sys_create((const char*)*(int *)(f->esp+4), (unsigned)*(int *)(f->esp+8));
      break;
    case SYS_REMOVE:
      f->eax = sys_remove((const char*)*(int *)(f->esp+4));
      break;
    case SYS_OPEN:
      f->eax = sys_open((const char*)*(int *)(f->esp+4));
      break;
    case SYS_FILESIZE:
      f->eax = sys_filesize(*(int *)(f->esp+4));
      break;
    case SYS_READ:
      {
        int fd = *(int*)(f->esp+4);
        void* buffer = (void *)*(int*)(f->esp+8);
        unsigned size = *(unsigned*)(f->esp+12);
        f->eax = sys_read(fd,buffer,size);
      }
      break;
    case SYS_WRITE:
      {
        int fd = *(int*)(f->esp+4);
        void* buffer = (void *)*(int*)(f->esp+8);
        unsigned size = *(unsigned*)(f->esp+12);
        f->eax = sys_write(fd,buffer,size);
      }
      break;
    case SYS_SEEK:
      {
        int fd = *(int*)(f->esp+4);
        unsigned position = *(unsigned*)(f->esp+8);
        sys_seek(fd,position);
      }
      break;
    case SYS_TELL:
      f->eax = sys_tell(*(int*)(f->esp+4));
      break;
    case SYS_CLOSE:
      sys_close(*(int*)(f->esp+4));
      break;
    default:
      sys_exit(-1);
  }
}



void sys_halt(void){
  shutdown_power_off();
}
void sys_exit(int status){
  struct thread* cur = thread_current();	
  printf("%s: exit(%d)\n",cur->name,status);
  cur->exit_status = status;
  thread_exit();
}
int sys_exec(const char *file){
  check_user_vaddr(file);
  int size = strlen(file)+1;
  char *fn_copy = palloc_get_page(0);
  if((fn_copy == NULL){
    sys_exit(-1);
  }
  strlcpy(fn_copy,file,size);
  return process_execute(fn_copy);
}	
int sys_wait(int pid){
  check_user_vaddr(pid);
  return process_wait(pid);
}
bool sys_create(const char *file, unsigned initial_size){
  if(file==NULL)
    sys_exit(-1);
  check_user_vaddr(file);
  return filesys_create(file,initial_size);
}
bool sys_remove(const char *file){
  if(file==NULL)
    sys_exit(-1);
  check_user_vaddr(file);
  return filesys_remove(file);
}
int sys_open(const char* file){
  if(file == NULL)
    sys_exit(-1);
  check_user_vaddr(file);
  struct file* return_file = filesys_open(file);
  if (return_file == NULL){
    return -1;
  }else{
    int i;
    for (i=3;i<128;i++){
      if(getfile(i)==NULL)
      {
        if(strcmp(thread_current()->name,file)==false)
          file_deny_write(return_file);
        thread_current()->fd[i]=return_file;
        return i;
      }
    }
  }
  return -1;
}
int sys_filesize(int fd){
  struct file* f = getfile(fd);
  if(f==NULL)
    sys_exit(-1);
  else
    return file_length(f);
}
void sys_seek(int fd, unsigned position){
  struct file* f = getfile(fd);
  if(f==NULL)
    sys_exit(-1);
  else
    return file_seek(f,position);
}
unsigned sys_tell(int fd){
  struct file* f = getfile(fd);
  if(f==NULL)
    sys_exit(-1);
  else
    return file_tell(f);
}
void sys_close(int fd){
  struct file* f = getfile(fd);
  if(f==NULL)
    sys_exit(-1);
  else{
    file_close(f);
    thread_current()->fd[fd]=NULL;
  }
}
int sys_read(int fd,const void *buffer, unsigned size){
  check_user_vaddr(buffer);
  check_user_vaddr(buffer+size-1);
  if(fd==0){
    int i;
    for(i=0;i<size;i++){
      if(((char*)buffer)[i]=='\0') break;
    }
    return i;
  }else{
    struct file* f = getfile(fd);
    if(f==NULL) sys_exit(-1);
    else {
      return file_read(f,buffer,size);
    }
  }
}

int sys_write(int fd, const void *buffer, unsigned size){
  check_user_vaddr(buffer);
  check_user_vaddr(buffer+size-1);
  if(fd==1){
    putbuf(buffer,size);
    return size;
  }else{
    struct file* f = getfile(fd);
    if(f==NULL) sys_exit(-1);
    if(f->deny_write) file_deny_write(f);
    return file_write(f,buffer,size);
  }
}

struct file* getfile(int fd){
  return (thread_current()->fd[fd]);
}

void check_user_vaddr(const void* vaddr){
  if(!is_user_vaddr(vaddr)) sys_exit(-1);
}
